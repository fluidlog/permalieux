"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const A = require("./algebra");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const sparqljs_1 = require("sparqljs");
class Factory {
    constructor(dataFactory) {
        this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();
        this.stringType = this.createTerm('http://www.w3.org/2001/XMLSchema#string');
    }
    createAlt(left, right) { return { type: A.types.ALT, left, right }; }
    createAsk(input) { return { type: A.types.ASK, input }; }
    createBoundAggregate(variable, aggregate, expression, distinct, separator) {
        let result = this.createAggregateExpression(aggregate, expression, distinct, separator);
        result.variable = variable;
        return result;
    }
    createBgp(patterns) { return { type: A.types.BGP, patterns }; }
    createConstruct(input, template) { return { type: A.types.CONSTRUCT, input, template }; }
    createDescribe(input, terms) { return { type: A.types.DESCRIBE, input, terms }; }
    createDistinct(input) { return { type: A.types.DISTINCT, input }; }
    createExtend(input, variable, expression) { return { type: A.types.EXTEND, input, variable, expression }; }
    createFrom(input, def, named) { return { type: A.types.FROM, input, default: def, named }; }
    createFilter(input, expression) { return { type: A.types.FILTER, input, expression }; }
    createGraph(input, name) { return { type: A.types.GRAPH, input, name }; }
    createGroup(input, variables, aggregates) { return { type: A.types.GROUP, input, variables, aggregates }; }
    createInv(path) { return { type: A.types.INV, path }; }
    createJoin(left, right) { return { type: A.types.JOIN, left, right }; }
    createLeftJoin(left, right, expression) {
        if (expression)
            return { type: A.types.LEFT_JOIN, left, right, expression };
        return { type: A.types.LEFT_JOIN, left, right };
    }
    createLink(iri) { return { type: A.types.LINK, iri }; }
    createMinus(left, right) { return { type: A.types.MINUS, left, right }; }
    createNop() { return { type: A.types.NOP }; }
    createNps(iris) { return { type: A.types.NPS, iris }; }
    createOneOrMorePath(path) { return { type: A.types.ONE_OR_MORE_PATH, path }; }
    createOrderBy(input, expressions) { return { type: A.types.ORDER_BY, input, expressions }; }
    createPath(subject, predicate, object, graph) {
        if (graph)
            return { type: A.types.PATH, subject, predicate, object, graph };
        return { type: A.types.PATH, subject, predicate, object, graph: this.dataFactory.defaultGraph() };
    }
    createPattern(subject, predicate, object, graph) {
        let pattern = this.dataFactory.quad(subject, predicate, object, graph);
        pattern.type = A.types.PATTERN;
        return pattern;
    }
    createProject(input, variables) { return { type: A.types.PROJECT, input, variables }; }
    createReduced(input) { return { type: A.types.REDUCED, input }; }
    createSeq(left, right) { return { type: A.types.SEQ, left, right }; }
    createService(input, name, silent) { return { type: A.types.SERVICE, input, name, silent }; }
    createSlice(input, start, length) {
        start = start || 0;
        if (length !== undefined)
            return { type: A.types.SLICE, input, start, length };
        return { type: A.types.SLICE, input, start };
    }
    createUnion(left, right) { return { type: A.types.UNION, left, right }; }
    createValues(variables, bindings) { return { type: A.types.VALUES, variables, bindings }; }
    createZeroOrMorePath(path) { return { type: A.types.ZERO_OR_MORE_PATH, path }; }
    createZeroOrOnePath(path) { return { type: A.types.ZERO_OR_ONE_PATH, path }; }
    createAggregateExpression(aggregator, expression, distinct, separator) {
        if (separator)
            return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.AGGREGATE, aggregator: aggregator, expression, separator, distinct };
        return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.AGGREGATE, aggregator: aggregator, expression, distinct };
    }
    createExistenceExpression(not, input) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.EXISTENCE, not, input }; }
    createNamedExpression(name, args) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.NAMED, name, args }; }
    createOperatorExpression(operator, args) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.OPERATOR, operator, args }; }
    createTermExpression(term) { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.TERM, term }; }
    createWildcardExpression() { return { type: A.types.EXPRESSION, expressionType: A.expressionTypes.WILDCARD, wildcard: new sparqljs_1.Wildcard() }; }
    createTerm(str) {
        return rdf_string_1.stringToTerm(str, this.dataFactory);
    }
    // Update functions
    createCompositeUpdate(updates) { return { type: A.types.COMPOSITE_UPDATE, updates }; }
    createDeleteInsert(deleteQuads, insertQuads, where) {
        const result = { type: A.types.DELETE_INSERT };
        if (deleteQuads)
            result.delete = deleteQuads;
        if (insertQuads)
            result.insert = insertQuads;
        if (where)
            result.where = where;
        return result;
    }
    createLoad(source, destination, silent) {
        const result = { type: A.types.LOAD, source };
        if (destination)
            result.destination = destination;
        return this.addSilent(result, silent);
    }
    createClear(source, silent) {
        return this.addSilent({ type: A.types.CLEAR, source }, silent);
    }
    createCreate(source, silent) {
        return this.addSilent({ type: A.types.CREATE, source }, silent);
    }
    createDrop(source, silent) {
        return this.addSilent({ type: A.types.DROP, source }, silent);
    }
    createAdd(source, destination, silent) {
        return this.addSilent({ type: A.types.ADD, source, destination }, silent);
    }
    createMove(source, destination, silent) {
        return this.addSilent({ type: A.types.MOVE, source, destination }, silent);
    }
    createCopy(source, destination, silent) {
        return this.addSilent({ type: A.types.COPY, source, destination }, silent);
    }
    addSilent(input, silent) {
        if (silent)
            input.silent = silent;
        return input;
    }
}
exports.default = Factory;
//# sourceMappingURL=factory.js.map